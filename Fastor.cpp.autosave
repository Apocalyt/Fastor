//---------------------------------------------------//
#define HAS_SSE
#define HAS_AVX

//#include <commons/utils.h>
//#include <simd_vector/SIMDVector.h>
//#include <tensor/Tensor.h>
//#include <tensor/tensor_print.h>
//#include <tensor/tensor_funcs.h>
//#include <tensor_algebra/einsum.h>
//#include "expressions/expressions.h"
//#include <backend/voigt.h>
////#include <vdt/vdtMath.h>
////#include <Vc/Vc>
////#include "/home/roman/Downloads/eschnett-vecmathlib-477f9c85cf11/vecmathlib.h"

#include <Fastor.h>

using namespace Fastor;
using std::size_t;
using real = float;
enum {I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z};
//#define SIZE 3

//-------------------------END OF INCLUDES--------------------------//


template<typename T, size_t ... Rest0, size_t ... Rest1>
Tensor<T,Rest0...> scalar_contract(const Tensor<T,Rest0...>& a, const Tensor<T,Rest1...>& b) {
    Tensor<T,Rest0...> out; out.zeros();
    for (int i=0; i<4; ++i) {
        for (int j=0; j<4; ++j) {
            for (int k=0; k<4; ++k) {
                for (int l=0; l<4; ++l) {
                    for (int m=0; m<4; ++m) {
                        for (int n=0; n<4; ++n) {
                            out(k,l,m,n) += a(i,j,k,l)*b(i,j,m,n);
                        }
                    }
                }
            }
        }
    }
    return out;
}


//namespace Fastor {
//namespace details {

////    template<class X, class Y>
////    struct C {};

////    template<size_t ... Idx0, size_t ... Idx1>
////    struct C<Index<Idx0...>,Index<Idx1...>> {

//template<class T, class U>
//struct extractor_contract_3 {};

//template<size_t ... Idx0, size_t ... Idx1>
//struct extractor_contract_3<Index<Idx0...>, Index<Idx1...>> {
//    template<typename T, size_t ... Rest>
//    static int foo_impl(const Tensor<T,Rest...> &a) {return prod<Idx0...>::value+*(a.data());}
//};

//}

//template<class Idx0, class Idx1>
//auto too(const Tensor<real,3,3> &a) -> decltype(details::extractor_contract_3<Idx0,Idx1>::foo_impl(a)) {
//    return details::extractor_contract_3<Idx0,Idx1>::foo_impl(a); }
//}


namespace Fastor {
//using namespace details;
namespace details {
//namespace abc {

template<class T, class U>
struct extractor_contract_3 {

//    template<typename B, size_t ... Rest>
//    static int foo_impl(const Tensor<B,Rest...> &a) {return *(a.data());}

//    template<typename B, size_t ... Rest>
//    static int foo_impl(const Tensor<B,Rest...> &a) {return foo_impl<T,U>(a);}
};

template<size_t ... Idx0, size_t ... Idx1>
struct extractor_contract_3<Index<Idx0...>, Index<Idx1...>> {
    template<typename T, size_t ... Rest>
    static int foo_impl(const Tensor<T,Rest...> &a) {return prod<Idx0...>::value+*(a.data());}
};

}


template<class Idx0, class Idx1>
auto too(const Tensor<real,3,3> &a) -> decltype(details::extractor_contract_3<Idx0,Idx1>::foo_impl(a)) {
    return details::extractor_contract_3<Idx0,Idx1>::foo_impl(a); }

//template<class Idx0, class Idx1>
//auto too(const Tensor<real,3,3> &a) -> decltype(abc::extractor_contract_3<Idx0,Idx1>::foo_impl(a)) {
//    return abc::extractor_contract_3<Idx0,Idx1>::foo_impl(a); }
}

//template<class Idx0, class Idx1>
//auto too(const Tensor<real,3,3> &a) -> decltype(Fastor::details::extractor_contract_3<Idx0,Idx1>::foo_impl(a)) {
//    return Fastor::details::extractor_contract_3<Idx0,Idx1>::foo_impl(a); }



//fast simd optimised minimal tensor contraction library - fastor
int main() {

//    using namespace A;
//    Tensor<real,3,3> df0; df0.ones();
//    Tensor<real,3,3> df1; df1.ones();
////    print(static_cast<Tensor<real,3,3>>(df0+df1/df1-2/3.+sqrt(df1)+sinh(df0)));
//    print(too<Index<2,3,4>,Index<2,3,6>>(df0));
////    soo<Index<I,J>,Index<I,K>>(df0,df1);
//    return 0;

//    Tensor<double,4,4,4,4> ss10, ss11;
////    ss10.random(); ss11.random();
//    ss10.iota(0); ss11.iota(0);

//    timeit(static_cast<Tensor<double,4,4,4,4> (*)(const Tensor<double,4,4,4,4>&,const Tensor<double,4,4,4,4>&)>(&scalar_contract),ss10,ss11);
//    timeit(static_cast<Tensor<double,4,4,4,4> (*)(const Tensor<double,4,4,4,4>&,
//                                                  const Tensor<double,4,4,4,4>&)>(&contraction<Index<I,J,K,L>,Index<I,J,M,N>>),ss10,ss11);
////    auto ss12 = scalar_contract(ss10,ss11);
////    auto ss13 = contraction<Index<I,J,K,L>,Index<I,J,M,N>>(ss10,ss11);
////    print(ss12,ss13);

//    return 0;

//    println(2,3,4,5,"\n");
//    return 0;

//    constexpr int tr[5] = {2,3,5,4,4};
//    int as[] = {0,0,0,0,0};
//    for_loop(tr,480,as);
//    print();
//    print(for_loop(tr,480));
//    print(recursive(tr,480));

//    for (int i=0; i<5; ++i) {
//        print(find_remaining(tr,480,i));
//    }

//    eyy<300,Tensor<double,2,3,5,4,4>,typename std_ext::make_index_sequence<5>::type>::foo();
//    print(eyy<300,Tensor<double,2,3,5,4,4>,typename std_ext::make_index_sequence<5>::type>::values);
//    print(get_all2<300,2,3,5,4,4>());
//    print(cartesian_product<Tensor<double,2,3,5,4,4>,typename std_ext::make_index_sequence<480>::type>::values);

//    return 0;


    //
//    Tensor<double,2,4> ss1;
//    Tensor<double,4,2> ss2;
//    ss1.iota(0); ss2.iota(0);
//    ss1 /= ss2;
//    print(ss1,ss2);
//    auto ss3 = matmul(ss1,ss2);
//    print(ss3);
//    auto ss4 = contraction<Index<I,J>,Index<J,K>>(ss1,ss2);
//    contraction<Index<I,J>,Index<J,K>>(ss1,ss2);
//    print(ss4);


//    Tensor<real,2,4> ss1;
////    Tensor<real,4,2> ss2;
//    Tensor<real,4,4> ss2;
//    ss1.iota(0); ss2.iota(0);
////    auto ss4 = contraction<Index<I,J>,Index<J,K>>(ss1,ss2);
//    print(ss1,ss2);
//    auto ss4 = matmul(ss1,ss2);
//    print(ss4);


//    Tensor<double,2,3,5> ss1;
//    Tensor<double,2,3,4> ss2;
//    ss1.iota(0); ss2.iota(0);
//    auto ss4 = contraction<Index<I,J,K>,Index<I,J,L>>(ss1,ss2);
////    contraction<Index<I,J,K>,Index<I,J,L>>(ss1,ss2);
////    print(ss1,ss2);
//    print(ss4);


    Tensor<real,2,3,5,4> ss1;
    Tensor<real,2,3,4> ss2;
    Tensor<real,2,4> ss3;
//    Tensor<real,3,3> ss3;
//    Tensor<real> ss3=5;
//    print(ss3);
    ss1.iota(0); ss2.iota(0);
    ss3.iota(0);
//    auto ss4 = contraction<Index<I,J,K,M>,Index<I,J,L>>(ss1,ss2);
//    auto ss4 = contraction<Index<I,J,K,M>,Index<O,L>>(ss1,ss3);
//    auto ss4 = contraction<Index<I,J,L>,Index<O,L>>(ss2,ss3);
//    auto ss4 = contraction<Index<I,J>,Index<K,J>>(ss3,ss3);
//    auto ss4 = contraction<Index<I,J>,Index<I,K>>(ss3,ss3);
//    auto ss4 = contraction<Index<I,J>,Index<I,J>>(ss3,ss3);
//    auto ss4 = reduction(ss3,ss3);
//    auto ss4 = reduction(ss1,ss1);
//    auto ss4 = contraction<Index<I,J,K,M>,Index<I,J,L>,Index<O,L>>(ss1,ss2,ss3);
//    auto ss4 = contraction<Index<I,J,K,M>,Index<I,J,L>,Index<O,L>,Index<O,Q>>(ss1,ss2,ss3,ss3);
//    auto ss4 = contraction<Index<I,J,K,M>,Index<I,J,L>,Index<O,L>,Index<O,Q>,Index<R,S,K,M>>(ss1,ss2,ss3,ss3,ss1);
//    auto ss4 = contraction<Index<I,J,K,M>,Index<I,J,L>,Index<O,L>,Index<O,Q>,Index<R,S,K,M>,Index<R,T>>(ss1,ss2,ss3,ss3,ss1,ss3);
//    contraction<Index<I,J,K>,Index<I,J,L>>(ss1,ss2);
//    print(ss1,ss2);
//    auto ss4 = reshape<5,4,3,2>(ss1);
    print(type_name<decltype(ss4)>());

//    auto ss4 = contraction<Index<I,J,K,M>,Index<O,L>>(ss1,ss3);
//    print(type_name<decltype(ss4)>());
//    print("\n\n\n");
//    auto ss5 = contraction<Index<I,J,K,L,M,N>,Index<I,J,N>>(ss4,ss2);
    print(ss4);
//    print(ss5);
//    print(ss2);
    unused(ss4);
//    unused(ss5);







    return 0;
    


//    Tensor<real,3,3> yy1,yy2;
//    cross(yy1,yy2);

//    nprods<Index<2,2,2,2,4>,typename std_ext::make_index_sequence<5>::type>::generate();
//    print<size_t,5>(nprods<Index<5,2,2,3,4>,typename std_ext::make_index_sequence<5>::type>::values);

//    Tensor<real,2,2> t3, t4;
//    Tensor<real,5,2,2,3,4> t3, t4;
//    t3.iota(0); t4.arange(0);
////    print(t3,t4);
//    outer(t3,t4);
//    print(outer(t3,t4));
//    auto t5 = einsum<Index<I,J>,Index<K,L>>(t3,t4);
//    print(einsum<Index<I,J>,Index<K,L>>(t3,t4));


//    using aa3 = ct::cartesian<ct::vl<0,1,2>, ct::vl<0,1,2>>;
//    std::cout << aa3() << std::endl;
//    return 0;

//    Tensor<float,3,4,5,8> qq1;
//    Tensor<float,3,4,4> qq2;
////    Tensor<double,3,4,5,8> qq1;
////    Tensor<double,3,4,4> qq2;
//    qq1.arange(0); qq2.arange(1);
//    auto qq5 = contraction<Index<0,1,2,3>,Index<0,1,5>>(qq1,qq2);
//    unused(qq5);
//    print(qq5);
//    return 0;

//    Tensor<float,2,3,4,5,2> qq1;
//    Tensor<float,2,3,3,4> qq2;
//    Tensor<double,2,3,4,5,2> qq1;
//    Tensor<double,2,3,3,4> qq2;
//    qq1.arange(0); qq2.arange(1);
//    auto qq5 = contraction<Index<0,1,2,3,7>,Index<4,1,5,6>>(qq1,qq2);
//    unused(qq5);
//    print(qq5);
//    return 0;

    Tensor<float,3,4,5,4> qq1; qq1.iota(0);
    auto qq2 = permutation<Index<1,2,3,0>>(qq1);
    print(qq2);
    return 0;


//    Tensor<double,2,3,4> qq1;
//    Tensor<double,5,3,6,4> qq2;
//    Tensor<double,8,9,5,6,7> qq3;
//    auto qq5 = contraction<Index<0,1,2>,Index<3,1,4,2>,Index<6,7,3,4,5>>(qq1,qq2,qq3);

//    print(type_name<decltype(qq5)>());
//    print(type_name<decltype(permutation<Index<2,1,0>>(qq1))>());

//    einsum<Index<0,1,2>,Index<3,0,4,2>,Index<6,7,3,4,5>>(qq1,qq2,qq3);

//    return 0;

//    using UU = typename nprods<Index<2,3,5,4>,typename std_ext::make_index_sequence<4>::type>::type;
//    print<size_t, 4>(UU::_IndexHolder);
//    size_t ss3[4] = {2,3,4,5};
//    print(products(ss3,1));
//    print(type_name<UU>());
//    print(typename nprods<Index<2,3,4>,typename std_ext::make_index_sequence<3>::type>::values);
//    print(type_name<concat<int,bool>>());

//    print(prod<2,3>::value)
//    print<int,3>(food<2,3,4>::arr);

//    print(binomial<100>::value[95]);
//    print(std_ext::make_index_sequence<10>());
//    index_generator3<3,3>();
//    timeit(static_cast<int (*)()>(&index_generator1<2,2,2,3,2,2,2,20>));
//    timeit(static_cast<int (*)()>(&index_generator2<2,2,2,3,2,2,2,20>));
//    timeit(static_cast<int (*)()>(&index_generator3<2,2,2,3,2,2,2,20>));

//    print(type_name<std_ext::make_index_sequence<5>>());
//    return 0;

//    timeit(static_cast<void (*)()>(&iterate_over_scalar<4>));
//    timeit(static_cast<void (*)()>(&iterate_over<3>));

//    constexpr size_t n1 = 3;
//    constexpr size_t n2 = 4;
//    Tensor<real,n1,n1,n1,n2> ts1; ts1.random();
//    Tensor<real,n1,n1,n1,n2> ts2; ts2.random();
//    timeit(static_cast<void (*)(const Tensor<real,n1,n1,n1,n2>&,const Tensor<real,n1,n1,n1,n2>&)>(&iterate_over<n1,n1,n1,n2>),ts1,ts2);
//    return 0;


//    timeit(static_cast<void (*)()>(&while_variant<1,1,1>));
//    timeit(static_cast<void (*)()>(&for_variant<1,1,1>));
//    for_variant<2,3,3>();
//    while_variant<2,3,3>();



//    using REAL = float;
//    Tensor<REAL,3,3> ggg; ggg.iota(0);
//    print(matmul(ggg,ggg));
//    print(static_cast<Tensor<REAL>>(ldeterminant(ggg)));
//    print(norm(cofactor(ggg)));
//    print(norm(transpose(adjoint(ggg))));
//    print(t5);
//    print(voigt(t5));
//    return 0;

//    constexpr auto ttt = 3;
//    real *ass   = static_cast<real*>(_mm_malloc(sizeof(real) * ttt*ttt, 32));
//    real *bss   = static_cast<real*>(_mm_malloc(sizeof(real) * ttt*1, 32));
//    real *outss = static_cast<real*>(_mm_malloc(sizeof(real) * ttt*1, 32));
//    std::iota(ass,ass+ttt*ttt,0);
//    std::iota(bss,bss+ttt,4.5);

//    print<real,ttt*ttt>(ass);
//    print<real,ttt>(bss);

//    print(foo<·>)
//    _matmul<real,ttt,ttt,1>(ass,bss,outss);
//    print<real,ttt>(outss);

//    Tensor<double,1,2,3,1,5,2,2,4,3,2,3,7,6> tensor_11;
//    tensor_11.iota(0);
//    print(tensor_11);
//    print(tensor_11.rank());

//    Tensor<real,4,5> ass; ass.arange(0);
//    Tensor<real,5,4> bss; bss.arange(0);

//    Tensor<real,4,4> ass; ass.arange(0);
//    Tensor<real,4,4> bss; bss.arange(0);
//    Tensor<real,2,3> ass; ass.arange(0);
//    Tensor<real,3,8> bss; bss.arange(0);
//    print(ass,bss);
//    print(matmul(ass,bss));


//    return 0;


    constexpr auto n=3;
//    Tensor<real,n,n,n> x; x.random();
//    Tensor<real,n,n,n> y; y.random();
//    auto z = einsum<Index<I,J,K>,Index<L,M,O>>(x,y);
//    print(z.data());

//    return 0;

//    constexpr auto tt0 = 2;
//    constexpr auto tt = tt0*tt0;
//    constexpr auto tt = 4;
//    real *as = static_cast<real*>(_mm_malloc(sizeof(real) * tt*tt, 32));
//    real *bs = static_cast<real*>(_mm_malloc(sizeof(real) * tt*tt, 32));
//    real *outs = static_cast<real*>(_mm_malloc(sizeof(real) * tt*tt, 32));
//    std::iota(as,as+tt*tt,0);
//    std::iota(as,as+tt*tt,0);
//    std::fill(bs,bs+tt*tt,3);

//    timeit(static_cast<void (*)(const real*, const real*, real*)>(&iterate_over_scalar<tt>),as,bs,outs);
//    timeit(static_cast<void (*)(const real*, const real*, real*)>(&iterate_over<tt>),as,bs,outs);

    return 0;
//    _adjoint<real,tt,tt>(as,outs);

//    Tensor<real,tt,tt> jj;
//    jj.iota(0);
//    jj.random();
//    print(jj);
//    print(adjoint(jj));
//    print(cofactor(jj));

    Tensor<real,3,3> ss; ss.iota(0);
//    ss(2,2) = 1;
    print(ss);
//    print(determinant(ss));
//    Tensor<real> dd = ldeterminant(ss);
//    Tensor<real,4,3> dd = ltranspose(ss);
//    Tensor<real,3,3> dd = ladjoint(ss);
//    Tensor<real,3,3> dd; dd = ltranspose(ladjoint(ss));
    Tensor<real,3,3> dd; dd = linverse(ss);
//    auto dd = ltranspose(lcofactor(ss));
    print(type_name<decltype(dd)>());
    print(dd);
//    print(norm(dd));
    Tensor<real,3,3> sdf = ss+ss/ss*ss-ss+sqrt(ss)+cosh(ss)/5+log(ss)+tanh(ss);
    print(sdf);

//    print(kronecker_delta<real,2,2>());

//    Tensor<real,3,4,5,6,7> tmp; tmp.iota(0);
////    Tensor<real,3,4,5,6,7> t2 = permutation<Index<M,L,K,J,I>>(tmp);
//    Tensor<real,3,4,5,6,7> t2 = permutation<Index<M,L,K,I,J>>(tmp);
//    print(t2);

    Tensor<real,3,4,5> tmp; tmp.iota(0);
//    Tensor<real,3,4,5,6,7> t2 = permutation<Index<M,L,K,J,I>>(tmp);
    Tensor<real,3,4,5> t2 = permutation<Index<J,K,I>>(tmp);
//    auto t2 = permutation<Index<J,K,I>>(tmp);
    print(t2);

//    using uu = typename permute_impl<real,Index<0,2,1>, Tensor<real,3,4,5>, typename std_ext::make_index_sequence<3>::type>::type;
//    print(type_name<uu>());


//    return 0;

//    Tensor<real,3,3,3> jj; jj.eye();
//    Tensor<real,2,3> jj = kronecker_delta<real,4,4>(); // runtime error
//    Tensor<real,3,3> jj, pp;
//    jj.iota(0); pp.iota(1);

//    Tensor<real,3,3,3> jj;
//    Tensor<real,3,3,3,3> jj;
//    jj.iota(0);
//    Tensor<real,2,3,4> jj;
//    jj.iota(0);
////    permutation<Index<I,K,J>>(jj);
////    print(permutation<Index<K,J,I>>(jj));
////    print(reshape<Index<K,J,I>>(jj));
////    reshape<Index<K,J,I,M>>(jj);
////    print(permutation<Index<I,K,J>>(jj));
//    print(jj);
//    pp.eye();
//    Tensor<real,3,3> cof_jj = jj/2+jj*jj+jj/jj+cofactor(jj)+adjoint(jj);
//    Tensor<real> gk = ltrace(lmatmul(ltranspose(jj),pp));
//    print(gk);

//    print(lmatmul(jj,pp).eval(1,2));
//    print(type_name<decltype(lmatmul(jj,pp).eval(1,2))>());
//    print(pp.is_orthogonal());
//    print(jj,cof_jj);
//    print(jj,transpose(jj));
//    print(matmul(jj,pp));
//    print(jj.is_equal(pp));
//    print(reduction(jj));
//    return 0;

//    foo<4,5,6,7> qq;
//    lists<0,2,3,1> ww;
//    auto ee = bar(ww,qq);

    Tensor<real,2,3,4,5> qq; qq.iota(0);
    auto ee = permutation<Index<0,2,3,1>>(qq);
    print(ee);
//    Index<0,2,3,1> ww;
//    auto ee = permutation(ww,qq);
//    print(type_name<decltype(ee)>());
//    using uu = typename meow<lists<0,2,1,3>, foo<4,5,6,7>,   typename std_ext::make_index_sequence<4>::type>::type;
//    print(type_name<uu>());
//    return 0;


    Tensor<real,3,4> ff; ff.iota(0);
    Tensor<real,4,3> kk; kk.iota(9);
    Tensor<real,4,4> ll; ll.fill(2);
    print(ff,kk);
//    Tensor<real,4,4> fh = matmul(kk,ff);
//    Tensor<real,4,4> fh = matmul(matmul(kk,ff),kk);
//    print(fh);
//    Tensor<real> fh = trace(matmul(transpose(ff),kk));
//    Tensor<real,3,3> fh = times(ff,kk);
//    print(fh);
//    print(type_name<decltype(fh)>());


//    constexpr int dims[7] = {0,1,2,3,4,1,0};
//    print(TC::is_uniq<7>(dims,2));

//    using uu = typename TC::contraction_impl<Index<0,0,1,1>, Tensor<double,2,2,3,3>, std::make_index_sequence<4> >::type;
//    print(type_name<uu>());
//    print(2);
//    constexpr int dd[] = TONY::make_index_sequence<4>();
//    Array<double,3,3,4,5> of;
//    Indices<I,I,K,L> fo;
//    TC::contraction(fo,of);
    return 0;

//    using uu = typename ContractionType<Index<0, 0>, Tensor<double, 3, 3>>::type;
//    using uu = typename ContractionType<Index<0, 0, 1>, Tensor<double, 3, 3, 3>>::type;
//    using uu = typename ContractionType<Index<0, 1, 0, 1>, Tensor<double, 3, 4, 3, 4>>::type;
//    print(type_name<uu>());

//    return 0;

//    print(no_of_uniques2<0,1,2,3,4,5,6>::value);
//    my_struct<0,5,2,3,5,0,3,2> ff;
//    print(ff.value);
//    auto fg = foos(ff);
//    print(fg.value);
//    return 0;

//    Tensor<real,3,3,5,6,3,3,3> ff; ff.iota(0);
//    Tensor<real,3> ff_out;
//    Index<I,I,J,K,L,L,L> indices;
//    einsum(indices, ff,ff_out);


//    Tensor<real,2,2> ff; ff.random();
//    print(ff);
//    print(reduction(ff));

//    return 0;


//    Tensor<real,3,3,4,3> oo;
//    Index<I,I,K,I> idx;
//    einsum(idx,oo);
//    einsum<Index<I,I,K,I>>(oo);
//    return 0;


//    print(no_of_uniques2<0,1,2,1,2,2>::value);


//    Tensor<real,2,3,2,3,4,2,3> gg; gg.iota(1.f);
    Tensor<real,n,n> gg; gg.iota(0.1);
//    Tensor<real,n,n> hh; hh.iota(4);
    Tensor<real,n,n> hh; hh.iota(1.5);

//    Tensor<real,n,n> ghh;
//    matmul<real,n,n,n>(gg.data(),hh.data(),ghh.data());
//    print(ghh);

//    print(Index<0,1,2>::Dimension);
//    auto gh = einsum<Index<0,1>,Index<1,2>>(gg,hh);
//    auto gh = einsum<Index<I,J>,Index<K,L>>(gg,hh);
//    Tensor<real,n,n> gh = sqrt(gg/2.) + einsum<Index<0,1>,Index<1,2>>(gg,hh) + log(gg*hh);
//    print(type_name<decltype(sqrt(gg/2.) + einsum<Index<I,J>,Index<J,K>>(gg,hh) + log(gg*hh))>());
//    Tensor<real,n,n> gh =times(gg,hh); //times(gg,hh);
//    Tensor<real,n,n> gh = trans(gg);
//    Tensor<real,n,n> gh = tr(gg);
//    Tensor<real,1,1> gh = tr(gg);
//    Tensor<real,n,n> gh = tr(times(trans(gg),hh));
//    Tensor<real,1,1> gh = tr(times(hh,hh));
//    Tensor<real,n,n> gh = times(hh,hh);
//    Tensor<real,n,n> gh = times(times(hh,gg),hh);
//    Tensor<real,n,n> gh = tr(times(gg,hh));
//    Tensor<real,n+1,n+5> gh = times(hh,gg);
//    Tensor<real,n+1,n+5> gh = tr(times(hh,gg));
//    Tensor<real,1,1> gh = tr(times(hh,gg));
//    Tensor<real,n+1,n+1> gh = times(hh,gg);
//    Tensor<real,1,1> gh = tr(times(hh,gg));
//    print(type_name<decltype(tr(times(gg,hh)))>());
//    print(gg,hh,gh);
//    print(type_name<decltype(tr(times(trans(gg),hh)))>());
//    Tensor<real,2,2> gh = 2+gg+2+hh;
//    Tensor<real,2,2> gh = sqrt(2-gg+hh/5+gg*2);
//    Tensor<real,2,2> gh = 2-gg-2+6;
//    Tensor<real,2,2> gh = multiply(2,multiply(gg,2)); //-2+6;
//    Tensor<real,2,2> gh = gg/2+2*2; //-2+6;
//    print(type_name<decltype(multiply(2,multiply(gg,2)))>());
//    print(type_name<decltype(gg/2+2*3-hh)>());
//    Tensor<real,2,2> gh = multiply(gg,hh);
//    print(type_name<decltype(sqrt(2-gg+hh/5-gg*2)+log(gg)+sin(sinh(hh)))>());
//    print(gg,hh,gh);

//    print(is_arithmatic<AbstractTensor<Tensor<real,2,2>,2>>::value);
//    print(is_arithmatic<std::remove_reference<const float&>::type>::value);
//    print(is_arithmatic<const float&>::value);
//    return 0;
//    Tensor<real,2,2> ff;
//    ff.fill((real)2);
////    print(ff);
////    auto gg = foo(ff);
//    Tensor<real,2,2> gg = foo(ff);
////    foo(ff);
////    gg.eval(0);
//    print(ff,gg);

//    return 0;

//    Tensor<real,2,3,2,3,2> xx;
//    Tensor<real,2,3,2,3,2,4> xx;
//    Tensor<real,2,3,4,5,6> xx;
//    Tensor<real,2,2,1> xx;
//    Tensor<real,2,3,4,5,6> xx;
//    print(prod<2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2>::value);
//    Tensor<real,3,3> xx, yy;
    Tensor<real,3,3> xx, yy;
//    Tensor<real,3,3,3> xx, yy;
//    Tensor<real,2,2,2> xx, yy;
//    Tensor<real,3,3,3,3> xx, yy;
    xx.iota((real)0);
    yy.iota((real)n*n);
//    xx(0,1,0,1,0);
//    print(xx(0,1,0,1,0,2));
//    print(xx(1,2,1,1,1,3));
//    print(xx,yy);

//    auto zz = einsum<Index<I,J>,Index<I,J>>(xx,yy);
//    auto zz = einsum<Index<I,J,K>,Index<I,J,K>>(xx,yy);
//    auto zz = einsum<Index<I,J,K,L>,Index<I,J,K,L>>(xx,yy);
//    auto zz = einsum<Index<K,K>>(xx);
//    auto zz = einsum<Index<M,N>,Index<N,K>>(xx,yy);
//    auto zz = einsum<Index<K,L>,Index<M,N>,Voigt>(xx,yy);
//    auto zz = einsum<Index<0,1>,Index<1,2>>(xx,yy);
//    auto zz = einsum<Index<I,J,K,L>,Index<L,M,N,O>>(xx,yy);

//    auto zz = einsum<Index<K,L>,Index<M,N>>(xx,yy);
//    auto zz = einsum<Index<I,K>,Index<J,L>>(xx,yy);
//    auto zz = einsum<Index<I,L>,Index<J,K>>(xx,yy);
//    auto zz = einsum<Index<J,I>,Index<L,K>>(xx,yy);
//    auto zz = einsum<Index<I,J>,Index<K,L>>(xx,yy);
//    auto zz = einsum<Index<I,J>,Index<K,L>,I,J>(xx,yy);
    auto zz = einsum<Index<I,J>,Index<K,L>>(xx,yy);
//    Tensor<real,n,n> zz = xx+yy;
//    Tensor<real,3,3,3,3> zz; zz.zeros();
    print(zz);

//    auto zz = einsum<Index<I,J,K>,Index<L,M,N>>(xx,yy);
//    auto zz = einsum<Index<J,I,K>,Index<M,L,N>>(xx,yy);
//    auto zz = einsum<Index<I,J,K>,Index<L,M,N>>(xx,yy);
//    Tensor<real,n,n,n,n,n,n> zz = einsum<Index<I,J,K>,Index<L,M,N>>(xx,yy);
//    print(zz(0,0,0));
//    print(zz(0,0,0,0,0,0));
//    print(zz);
//    Tensor<real,n,n,n,n,n,n> zz; zz.iota(0);
//    Tensor<real,1,1,1,1,4,5> zz; zz.iota(0);
//    print(zz);
//    print<real,729>(zz.data());

////    for (auto i=0; i<100; ++i)
////        for (auto j=0; j<1; ++j)
////            print(i);
    return 0;
    //---------------------------------------------------------------------





    //---------------------------------------------------------------------
    // Allocate
    real *aa = static_cast<real*>(_mm_malloc(sizeof(real) * n*n, 32));
    real *bb = static_cast<real*>(_mm_malloc(sizeof(real) * n*n, 32));
//    real *out = static_cast<real*>(_mm_malloc(sizeof(real) * n*n, 32));
//    real *cc = static_cast<real*>(_mm_malloc(sizeof(real) * 4, 32));
//    real *dd = static_cast<real*>(_mm_malloc(sizeof(real) * 4, 32));
    real *out = static_cast<real*>(_mm_malloc(sizeof(real) * n*n*n*n, 32));

//    assert(((size_t)(&out[3]) & 0xF) == 0);

    std::iota(aa,aa+n*n,static_cast<real>(0));
    std::iota(bb,bb+n*n,static_cast<real>(n*n));
//    std::iota(cc,cc+4,0.);
//    std::iota(dd,dd+4,4.);
//    std::fill(out,out+9,0.);
//    _mm_prefetch();
//    outer<real,n,n,n,n>(aa,bb,out);
//    crossproduct<n*n>(aa,bb,out);
//    runner_scalar(aa,bb,out);
//    runner(aa,bb,out);
//    tcross(aa,bb,out);
//    print<real,36>(out);
//    timeit(no_op);
//    timeit(static_cast<void (*)(const real*,const real*,real*)>(&tcross),aa,bb,out);
//    timeit(static_cast<void (*)(const real*,const real*,real*)>(&matmul<n,n>),aa,bb,out);
//    timeit(static_cast<void (*)(const real*,const real*,real*)>(&crossproduct<3,3>),aa,bb,out);
//    matmul<9>(aa,bb,out);
//    print<real,9>(out);
//    auto da = doublecontract<9>(aa,bb);
//    crossproduct<n,n>(aa,bb,out);
//    print(da);
//    print<double,SIZE*SIZE>(dd);

//    cyclic_0<real,n,n,n,n>(aa,bb,out);
//    runner(aa,bb,out);
    timeit(no_op);
//    timeit(static_cast<double (*)(const double*)>(&det<4>),cc);
//    timeit(static_cast<void (*)(const double*, double*)>(&transpose<SCALAR>),a,out);
    timeit(static_cast<real (*)(const real*, const real*)>(&_doublecontract<real,n,n>),aa,bb);
//    timeit(static_cast<void (*)(const double*, const double*, double*)>(&matmul<4>),cc,dd,out);
//    timeit(static_cast<void (*)(const real*, const real*, real*)>(&iterate_over_scalar<n>),aa,bb,out);
//    timeit(static_cast<void (*)(const real*, const real*, real*)>(&iterate_over<n>),aa,bb,out);

//    print<real,n*n>(out);
//    timeit(static_cast<void (*)(const real*, const real*, real*)>(&runner),aa,bb,out);
//    timeit(static_cast<void (*)(const real*, const real*, real*)>(&AijBkl),aa,bb,out);

//    Eigen::Matrix<double,SIZE,SIZE> b; b.setRandom(SIZE,SIZE);
//    Eigen::Matrix<double,SIZE,SIZE> c; c.setRandom(SIZE,SIZE);
//    timeit(static_cast<double (*)(const Eigen::Matrix<double,SIZE,SIZE>&)>(&det),b);
//    timeit(static_cast<Eigen::Matrix<double,3,3> (*)(const Eigen::Matrix<double,3,3>&)>(&transpose),b);
//    timeit(static_cast<double (*)(const Eigen::Matrix<double,SIZE,SIZE>&,const Eigen::Matrix<double,SIZE,SIZE>&)>(&doublecontract),b,c);
//    timeit(static_cast<Eigen::Matrix<double,SIZE,SIZE> (*)(const Eigen::Matrix<double,SIZE,SIZE>&,const Eigen::Matrix<double,SIZE,SIZE>&)>(&matmul),b,c);
//    timeit(static_cast<Eigen::Matrix<double,SIZE,SIZE> (*)(const Eigen::Matrix<double,SIZE,SIZE>&,const Eigen::Matrix<double,SIZE,SIZE>&)>(&runner),b,c);

//    Eigen::Matrix3Xd cc; cc.setRandom(3,3);
//    timeit(static_cast<double (*)(const Eigen::Matrix3Xd&)>(&det),cc);

    _mm_free(aa);
    _mm_free(bb);
//    _mm_free(cc);
//    _mm_free(dd);
    _mm_free(out);

    return 0;
}















//////////////////////////////////




//namespace stdl  // WARNING: at own risk, otherwise use own namespace
//{
//    template <size_t... Ints>
//    struct index_sequence
//    {
//        using type = index_sequence;
//        using value_type = size_t;
//        static constexpr std::size_t size() { return sizeof...(Ints); }
//    };

//    // --------------------------------------------------------------

//    template <class Sequence1, class Sequence2>
//    struct _merge_and_renumber;

//    template <size_t... I1, size_t... I2>
//    struct _merge_and_renumber<index_sequence<I1...>, index_sequence<I2...>>
//      : index_sequence<I1..., (sizeof...(I1)+I2)...>
//    { };

//    // --------------------------------------------------------------

//    template <size_t N>
//    struct make_index_sequence
//      : _merge_and_renumber<typename make_index_sequence<N/2>::type,
//                            typename make_index_sequence<N - N/2>::type>
//    { };

//    template<> struct make_index_sequence<0> : index_sequence<> { };
//    template<> struct make_index_sequence<1> : index_sequence<0> { };
//}
//////////////////////////////



//template <int...>
//struct Indices {};

//template <typename, int...>
//struct Array {};


//namespace TC {
//// is ind[i] unique in ind?
//template<size_t N>
//constexpr bool is_uniq(const int (&ind)[N], size_t i, size_t cur = 0){
//    return cur == N ? true :
//           (cur == i || ind[cur] != ind[i]) ? is_uniq(ind, i, cur + 1) : false;
//}

//// For every i where ind[i] == index, is dim[i] == dimension?
//template<size_t N>
//constexpr bool check_all_eq(int index, int dimension,
//                            const int (&ind)[N], const int (&dim)[N], size_t cur = 0) {
//    return cur == N ? true :
//           (ind[cur] != index || dim[cur] == dimension) ?
//                check_all_eq(index, dimension, ind, dim, cur + 1) : false;
//}

//// if position i should be contracted away, return -1, otherwise return dim[i].
//// triggers a compile-time error when used in a constant expression on mismatch.
//template<size_t N>
//constexpr int calc(size_t i, const int (&ind)[N], const int (&dim)[N]){
//    return is_uniq(ind, i) ? dim[i] :
//           check_all_eq(ind[i], dim[i], ind, dim) ? -1 : throw "dimension mismatch";
//}
////Now we need a way to get rid of the -1s:
//template<class Ind, class... Inds>
//struct concat { using type = Ind; };
//template<int... I1, int... I2, class... Inds>
//struct concat<Indices<I1...>, Indices<I2...>, Inds...>
//    :  concat<Indices<I1..., I2...>, Inds...> {};

//// filter out all instances of I from Is...,
//// return the rest as an Indices
//template<int I, int... Is>
//struct filter
//    :  concat<typename std::conditional<Is == I, Indices<>, Indices<Is>>::type...> {};
////Use them:
//template<class Ind, class Arr, class Seq>
//struct contraction_impl;

//template<class T, int... Ind, int... Dim, size_t... Seq>
//struct contraction_impl<Indices<Ind...>, Array<T, Dim...>, stdl::index_sequence<Seq...>>{
//    static constexpr int ind[] = { Ind... };
//    static constexpr int dim[] = { Dim... };
//    static constexpr int result[] = {calc(Seq, ind, dim)...};

//    template<int... Dims>
//    static auto unpack_helper(Indices<Dims...>) -> Array<T, Dims...>;

//    using type = decltype(unpack_helper(typename filter<-1,  result[Seq]...>::type{}));
//};

//template<class T, int ... Dims, int ... Idx,
//typename std::enable_if<sizeof...(Dims)==sizeof...(Idx),bool>::type=0>
//typename contraction_impl<Indices<Idx...>, Array<T,Dims...>,
//                          typename stdl::make_index_sequence<sizeof...(Dims)>::type>::type
//contraction(const Indices<Idx...> &idx, const Array<T,Dims...> &a) {
//    print("wow");
//}

//}
